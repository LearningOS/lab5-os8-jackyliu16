终归是完成了这个lab，其中同样出现了较多面临的由于我自身编程不够规范导致的错误
就比如在进行封闭debug的时候（只是为了使用cargo run)功能检测代码是否出现问题的时候
就总会出现类似于0 和 -1这种本来用于替位的东西没有删除（已经完成了对应的功能）

在我完成优先级调试的时候，也往往会出现一些可能由于我对于所有权的借用不太了解所产生的错误

就比如说在写具体代码的时候
如果直接使用
```rust
let inner = self.read_queue[i].inner_exclusive_access();
```
虽然看上去他的作用与
```rust
let task = &self.ready_queue[i];
let inner = task.inner_exclusive_access();
```
的内容几乎相同，但是二者所起到的作用并不相同。
这也是我在参考了github上其他dalao的代码才发现的问题
task 与 read_queue中的task 的关系是简单的借用关系，而inner与之又是一个全局唯一的借用关系，两个关系不能同时完成。


### 可能的建议
1. 优化对于前面样例的支持内容，尽可能降低用户在通过前面的样例的时候所出现的问题【但是同时，用户在完成之前的样例同样可以加深用户对于当前结构的理解】
2. 还是与前面说的一样，感觉可以有一个前后贯穿的主线流程，来帮助大家理解。
3，在本次测试中部分代码就比如说`mmap`和`unmap`的实现部分可以提供更多样例来帮助debug
